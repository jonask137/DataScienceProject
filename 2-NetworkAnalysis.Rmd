---
output: html_document
editor_options: 
  chunk_output_type: console
---


# Network Analysis

## Basics

The following is based on the file 1 - Basics

### Preliminaries

```{r}
# Loading the necessary libraries:
library(sna)

# sna stands for social network analysis. This library contains several routines for analysing networks.
# See the user guide for more information: https://cran.r-project.org/web/packages/sna/sna.pdf
```


### Creating a network from an adjacency matrix 


```{r}
# A random graph is a graph where the vertices are fixed, but the edges are drawn randomly and 
# independently from a Bernoulli distribution.

# Create an adjacency matrix for a single (m = 1) random graph with n vertices and edge probability tprob:
A <- rgraph(n=10 #Number of vertices 
            ,m=1 #Number of matrices to be made
            ,tprob=.25) #Probability of an edge

# Convert the adjacency matrix into a network object:
net_1 <- network(A, directed=TRUE, loops=FALSE, bipartite=FALSE, matrix.type="adjacency")

# We can also just use the defaults and write:
net_1 <- network(A)

# Summarise information about our network:
summary(net_1)

# A simple plot of the network:
plot(net_1)
```


### Creating a network from an edge list

```{r}
# Setting the random seed for reproducibility:
set.seed(1)

# "Random" numbers generated by a computer are not really random, but they can seem to be to humans.
# By setting the random "seed", we fix the sequence of random numbers. The next random graph we 
# create will be the same upon repeated runs of this script.

# We can also use rgraph to create an edge list:
el <- rgraph(n=10, m=1, tprob=.25, return.as.edgelist=T)

# The edge list is an [m x 3] matrix where m is the number of edges. The first column is the vertex
# the edge originates at, the second the vertex it terminates at and the final one the weight:
el

# We can create, plot and summarise this network as before:
net_2 <- network(el, directed=TRUE, loops=FALSE, bipartite=FALSE, matrix.type="edgelist")
summary(net_2)
plot(net_2)

# We can also use the shorter version, as the network command automatically infers that this is an edge list:
net_2 <- network(el)
```


### Examining properties of network objects

```{r}
# We can report various properties of our network:
is.network(net_2)        # Is it a network?
is.bipartite(net_2)      # Is it bipartite?
is.directed(net_2)       # Is it directed?
has.loops(net_2)         # Are loops allowed?  
network.size(net_2)      # What is the number of vertices, order of the network (as mentioned in the slides this is also sometimes called size)?
network.edgecount(net_2) # What is the number of edges?

# We can also access and modify particular edges:
    #Notice, that we are merely looking up the adjacency matrix
summary(net_2)
net_2[3,5]               # The edge from vertex 3 to vertex 5 (not present).
net_2[1:3,1:3]           # A submatrix of the adjacency.
net_2[3,5] <- 1          # Adding and edge from vertex 3 to 5.
net_2[1,]  <- 1          # Set edges from vertex 1 to all other vertices.
summary(net_2)

# Notice that [1,1] remained 0 after the final modification, because we set loops to false.
# Similarly, networks with directed set to false will be symmetrised.

# We can also add vertices and edges with these commands:
add.vertices(net_2, 2)
add.edges(net_2, 11,12)

# And we can delete them:
get.edgeIDs(net_2, 11)
delete.edges(net_2, get.edgeIDs(net_2, 11))
delete.vertices(net_2, 11)
delete.vertices(net_2, 11)
```


### Attributes of networks, vertices and edges

```{r}
# List the attributes of our network:
list.network.attributes(net_2)

# We can then get the values a particular attribute:
get.network.attribute(net_2, "bipartite")
get.network.attribute(net_2, list.network.attributes(net_2)[2])

# Similary, vertex and edge attributes:
list.vertex.attributes(net_2)
list.edge.attributes(net_2)

# The built-in "na" attribute tells you if a vertex/edge is "missing" or not.
# This refers to missing data, not if an edge is present or absent:
get.vertex.attribute(net_2, "na")
get.edge.attribute(net_2, "na")

# The vertex names (ids):
get.vertex.attribute(net_2, "vertex.names")
```
I guess that the names could be anything, e.g., if it reflected a friendship network, then the names could be actual names.

```{r}
# We can also add attributes:
set.edge.attribute(net_2, "new-attribute", 77)
list.edge.attributes(net_2)

# We can use either of the two to get the attribute values:
get.edge.attribute(net_2, "new-attribute")
get.edge.value(net_2, "new-attribute")

# Add a "gender" attribute for each vertex:
gender <- c(2,1,2,2,1,2,1,1,2,2)
set.vertex.attribute(net_2, "gender", gender)
list.vertex.attributes(net_2)
get.vertex.attribute(net_2, "gender")
```
Basically what we do with the attributes are to encapsule information in the vertices. So it could also be age, adress, mail etc.

```{r}
# Change the vertex names:
names <- c("John", "Mary", "Tom", "Bob", "Ann", "Pete", "Kate", "Jill", "George", "Tim")
set.vertex.attribute(net_2, "vertex.names", names)
get.vertex.attribute(net_2, "vertex.names")
summary(net_2)
```
Now we see the names are added to the adjecency matrix.

```{r}
# Add a "year" attribute to the network:
set.network.attribute(net_2, "year", 2008)
list.network.attributes(net_2)
get.network.attribute(net_2, "year")
```
So I guess, that this means to we add information to the overall model, hence could be date of creation or version.

```{r}
# Change the network to undirected by changing the "directed" attribute:
set.network.attribute(net_2, "directed", F)
summary(net_2)
plot(net_2)

# You can also delete attributes:
delete.network.attribute(net_2,"year")
delete.edge.attribute(net_2,"new-attribute")
delete.vertex.attribute(net_2,"gender")
```
We are now going to use a new operator: %n%, %e%, %v% = Various operators which allow extraction or replacement of various components of a network object. In general

+ n = network
+ e = edge
+ v = vertices

```{r}
# We can also get and set attributes using shorthand operators:
net_2 %n% "year" <- 2009          # %n% is for network
net_2 %n% "year"

net_2 %e% "new-attribute" <- 88   # %e% for edges.
net_2 %e% "new-attribute"     

net_2 %v% "gender" <- gender      # %v% for vertices.
net_2 %v% "gender"

summary(net_2)
```


## Visualizations


### Preliminaries

```{r}
# Loading the necessary libraries:
library(sna)
```

### Importing the data

```{r}
# Import the data:
campnet <- read.csv(file="Data/2b - campnet.csv", header=T, row.names=1, as.is=T)

# See the first few columns of the data:
head(campnet)

# The campnet dataset contains interactions among 18 people participating in a workshop (including 4 instructors). 
# An edge from vertex i to j indicates that person i listed person j as one of their top three interactors.

# Reading in the attributes:
campnet.attr <- read.csv(file="Data/2c - campnet_attr.csv", header=T, as.is=T)
campnet.attr
```

The attributes are:
Gender: 1: female,      2: male
Role:   1: participant, 2: instructor
Combo:  1: female,      2: male,      3: instructor (all males)


```{r}
# Set up the adjacency matrix and network:
A = as.matrix(campnet)
camp_net <- network(A)
summary(camp_net)
```


### Visualising the network

```{r}
# We can use the basic plot function to visualise the network:
plot(camp_net)

# sna also has the more flexible gplot function:
gplot(camp_net
      ,mode = "fruchtermanreingold" # The "mode" parameter selects the network layout.
      ,displaylabels = T # "displaylabels" shows the vertex labels.
      ,label.cex = 0.5 # label.cex = 0.5 sets the vertex label size to 0.5 of the default size.
      ,label.col="blue") # label.col = "blue" sets the color of all the labels to blue.
```

For a list of layouts, see: https://www.rdocumentation.org/packages/sna/versions/2.5/topics/gplot.layout or page 86 of https://cran.r-project.org/web/packages/sna/sna.pdf. Try for example circle, eigen, kamadakawaii, mds and spring.



```{r}
# Next we colour the vertices by gender:

modes <- c("adj","circle","circrand","eigen","fruchtermanreingold","geodist","hall","kamadakawai","mds","princoord","random","rmds","segeo","seham","spring","springrepulse","target")

for (i in modes) {
  gplot(camp_net
      ,mode = i #The network layout
      ,displaylabels = T
      ,label.cex = 0.5
      ,label.col = "blue"
      ,vertex.col = campnet.attr$Gender
      ,main = i)
}
```

Notice that we have something of a community structure in this network.

```{r}
# We can also ask R for specific colours for gender. First let's check out the colour names that R knows about:
colors()

# Create a vector of colours depending on gender:
vertex_colours <- ifelse(campnet.attr$Gender=="1","yellow","green")

# Then we plot:
gplot(camp_net, mode="fruchtermanreingold", displaylabels=T, label.cex=0.5, label.col="blue", vertex.col=vertex_colours)

# Notice that if we run the same command again, the vertex layout typically changes:
gplot(camp_net, mode="fruchtermanreingold", displaylabels=T, label.cex=0.5, label.col="blue", vertex.col=vertex_colours)

# This is normal, many layout algorithms return slightly different layouts upon repeated runs. However, suppose we want to 
# visualise the same network with different colourings. Then we want the vertices to be in the same place in all the figures.

# We can save the layout coordinates:
layout_coordinates <- gplot(camp_net, mode="fruchtermanreingold", displaylabels=T, label.cex=0.5, label.col="blue", vertex.col=vertex_colours)

# Then we can plot again using the same coordinates:
gplot(camp_net, displaylabels=T, label.cex=0.5, label.col="blue", vertex.col=campnet.attr$Role, coord = layout_coordinates, vertex.cex = 3)

# Examine the help file to find many more parameters controlling network visualisation: 
?sna::gplot
```

The following starts an PDF document, where we save plots in it. It is saved on the working directory

```{r}
# To save the plot to file, we first start a graphic device for PDFs, plot, and finally close the PDF device:
pdf("test.pdf")
gplot(camp_net, displaylabels=T, label.cex=0.5, label.col="blue", vertex.col=vertex_colours, coord=layout_coordinates)
dev.off()
```


